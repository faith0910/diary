### 										JAVA中常见的锁有哪些？

根据分类标准，我们把锁分为7大类别：

​		偏向锁/轻量级锁/重量级锁	

​		可重入锁/不可重入锁

​		共享锁/独占锁

​		公平锁/非公平锁	

​		悲观锁/乐观锁

​		自旋锁/非自旋锁

​		可中断锁/不可中断锁

**a.<u>偏向锁/轻量级锁/重量级锁**</u>(特指的是synchronized锁的三种状态，通过对象头的mark word来表明锁的状态)

​		偏向锁：如果自始至终，对于这把锁都不存在竞争，那么其实就没有必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化之后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当第一个线程来访问它并尝试获取锁时，它就将这个线程记录下来，以后如果尝试获取所的线程正是偏向锁的拥有者，就可以直接获取锁，开销很小，性能最好。

​		轻量级锁：jvm开发者发现很多情况下，synchronized中的代码是被多个线程交替执行的，而不是同时执行的，也就是说不存在实际的竞争，或者只有短时间的锁竞争，用CAS就可以解决，这种情况下，用完全互斥的重量级锁是没有必要的。轻量级锁指的是当锁原来是偏向锁时，被另一个线程访问，说明存在竞争,那么偏向锁就会升级为轻量级锁，线程会通过自旋的方式来尝试获取锁，而不会陷入阻塞。

​		重量级锁：重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程存在实际竞争时，且竞争时间比较长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其它申请却拿不到锁的线程进入阻塞状态。

​		你可以发现锁的升级路径：无锁---偏向锁---轻量级锁---重量级锁

​		综上所述，偏向锁的性能最好，可以避免CAS操作。而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁会把获取不到锁的线程阻塞，性能最差。

**b.**<u>**可重入锁/不可重入锁**<u>

​		可重入锁是指当前线程已经拥有这把锁了，能在不释放这把锁的情况下继续获取锁；同理不可重入锁就是指的是虽然当前线程持有了这把锁，但是如果想再次获取这把锁，也必须要释放了锁之后才可以再次尝试获取。

​		对于可重入锁而言，最典型的就是ReentrantLock了，正如它的名字一样，reentrant就是可重入的意思，它也是Lock接口的一个实现类。

**c.<u>共享锁/独占锁<u>**		

​		共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同事被一个线程获得。读写锁就很好的诠释了共享锁和独占锁的理念。读写锁中的读锁就是共享锁，而写锁是独占锁。读锁可以被同时被多个线程锁持有，而写锁最多只能同事被一个线程所持有。

**d.<u>公平锁/非公平锁<u>**

​		公平锁的含义在于如果线程拿不到这把锁，那么线程就会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么"完美"了，他会在一定的情况下，忽略到已经排队的线程，产生插队现象。

**e.<u>悲观锁/乐观锁<u>**

​		悲观锁的概念是，在获取资源之前必须要拿到锁，以便达到"独占"的状态，当前线程在操作资源的时候，其它线程由于拿不到锁，所以不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反乐观锁利用CAS理念，在不独占资源的情况下，完成了对资源的修改。

**f.<u>自旋锁/非自旋锁<u>**

​		自旋锁的理念是当前线程现在拿不到锁，并不直接陷入阻塞或者释放CPU资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象的比喻成"自旋"，就像是线程在进行"自我旋转"。相反，非自旋锁的理念是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其它的处理逻辑，去排队，陷入阻塞等等。

**g.<u>可中断锁/不可中断锁<u>**

​		在Java中，被synchronized关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路，必须拿到锁之后才能就行其它逻辑处理。而我们的ReentrantLock是一种典型的可中断锁，例如使用lockinterruptibly方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他事情，不需要一直等到获取锁之后才离开。